{
  "language": "Solidity",
  "sources": {
    "contracts/BaseRelayRecipient/BaseRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"./BaseRelayRecipientStorage.sol\";\n\n/**\n * A base contract to be inherited by any contract that want to receive relayed transactions\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\n */\n\nabstract contract BaseRelayRecipient is Context {\n\n  /*\n   * require a function to be called through GSN only\n   */\n//  modifier trustedForwarderOnly() {\n//    require(msg.sender == address(s.trustedForwarder), \"Function can only be called through the trusted Forwarder\");\n//    _;\n//  }\n\n  function isTrustedForwarder(address forwarder) public view returns(bool) {\n    return forwarder == BaseRelayRecipientStorage.layout().trustedForwarder;\n  }\n\n  /**\n   * return the sender of this call.\n   * if the call came through our trusted forwarder, return the original sender.\n   * otherwise, return `msg.sender`.\n   * should be used in the contract anywhere instead of msg.sender\n   */\n  function _msgSender() internal override virtual view returns (address ret) {\n    if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n      // At this point we know that the sender is a trusted forwarder,\n      // so we trust that the last bytes of msg.data are the verified sender address.\n      // extract sender address from the end of msg.data\n      assembly {\n        ret := shr(96,calldataload(sub(calldatasize(),20)))\n      }\n    } else {\n      return msg.sender;\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/BaseRelayRecipient/BaseRelayRecipientStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary BaseRelayRecipientStorage {\n  bytes32 internal constant STORAGE_SLOT = keccak256(\n    'diamond.storage.BaseRelayRecipientStorage'\n  );\n\n  struct Layout {\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address trustedForwarder;\n  }\n\n  function layout() internal pure returns (Layout storage l) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly { l.slot := slot }\n  }\n\n}\n"
    },
    "contracts/CyberDestinationFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n//\nimport '@solidstate/contracts/token/ERC1155/IERC1155.sol';\nimport \"./ERC1155URI/ERC1155URI.sol\";\nimport \"./BaseRelayRecipient/BaseRelayRecipient.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./Diamond/LibDiamond.sol\";\nimport \"./BaseRelayRecipient/BaseRelayRecipientStorage.sol\";\nimport \"./libraries/LibAppStorage.sol\";\n\ncontract CyberDestinationFactoryFacet is BaseRelayRecipient, ERC1155URI {\n\n  using ECDSA for bytes32;\n  using Counters for Counters.Counter;\n\n  event Minted(address indexed account, uint256 indexed tokenId, uint256 indexed amount);\n\n  function initialize(string memory _uri, address _manager, address _trustedForwarder, address _opensea) public {\n\n    require(LibDiamond.diamondStorage().contractOwner == msg.sender, \"NO\");\n\n    BaseRelayRecipientStorage.layout().trustedForwarder = _trustedForwarder;\n    LibDiamond.diamondStorage().supportedInterfaces[type(IERC1155).interfaceId] = true;\n    setURI(_uri);\n    LibAppStorage.layout().manager = _manager;\n    LibAppStorage.layout().opensea = _opensea;\n\n  }\n\n  function totalSupply() public view returns (uint256) {\n\n    return LibAppStorage.layout().totalSupply.current();\n\n  }\n\n  function manager() public view returns (address) {\n\n    return LibAppStorage.layout().manager;\n\n  }\n\n  function minterNonce(address _minter) public view returns (uint256){\n\n    return LibAppStorage.layout().minterNonce[_minter].current();\n\n  }\n\n  function mint(string memory _uri, uint256 _amount, bytes memory _signature) public returns (uint256 _tokenId) {\n\n    address sender = _msgSender();\n    uint256 nonce = minterNonce(sender);\n\n    bytes memory _message = abi.encodePacked(_uri, _amount, nonce, sender);\n    address _recoveredAddress = keccak256(_message).toEthSignedMessageHash().recover(_signature);\n    require(_recoveredAddress == LibAppStorage.layout().manager, \"NM\");\n\n    // Mint token\n    _tokenId = LibAppStorage.layout().totalSupply.current();\n    setTokenURI(_tokenId, _uri);\n    LibAppStorage.layout().totalSupply.increment();\n    LibAppStorage.layout().minterNonce[sender].increment();\n    _safeMint(sender, _tokenId, _amount, \"\");\n\n    emit Minted(sender, _tokenId, _amount);\n\n    if(!isApprovedForAll(sender, LibAppStorage.layout().opensea) ){\n\n      setApprovalForAll(LibAppStorage.layout().opensea, true);\n\n    }\n\n    return _tokenId;\n\n  }\n\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '../../introspection/IERC165.sol';\n\ninterface IERC1155 is IERC165 {\n  event TransferSingle (\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256 id,\n    uint256 value\n  );\n\n  event TransferBatch (\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256[] ids,\n    uint256[] values\n  );\n\n  event ApprovalForAll (\n    address indexed account,\n    address indexed operator,\n    bool approved\n  );\n\n  event URI (\n    string value,\n    uint256 indexed id\n  );\n\n  function balanceOf (\n    address account,\n    uint256 id\n  ) external view returns (uint256);\n\n  function balanceOfBatch (\n    address[] calldata accounts,\n    uint256[] calldata ids\n  ) external view returns (uint256[] memory);\n\n  function setApprovalForAll (\n    address operator,\n    bool approved\n  ) external;\n\n  function isApprovedForAll (\n    address account,\n    address operator\n  ) external view returns (bool);\n\n  function safeTransferFrom (\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  function safeBatchTransferFrom (\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/ERC1155URI/ERC1155URI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@solidstate/contracts/token/ERC1155/ERC1155.sol\";\nimport \"./ERC1155URIStorage.sol\";\n\nabstract contract ERC1155URI is ERC1155 {\n\n  function uri(uint256 _tokenId) public view virtual returns (string memory) {\n\n    string memory tokenURI = ERC1155URIStorage.layout().tokenURIs[_tokenId];\n    require(bytes(tokenURI).length != 0, \"ERC1155URI: tokenId not exist\");\n    return string(abi.encodePacked(ERC1155URIStorage.layout().uri, tokenURI));\n\n  }\n\n  function setURI(string memory new_uri) internal virtual {\n    ERC1155URIStorage.layout().uri = new_uri;\n  }\n\n  function setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n    ERC1155URIStorage.layout().tokenURIs[tokenId] = _tokenURI;\n  }\n\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n        } else if (signature.length == 64) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let vs := mload(add(signature, 0x40))\n                r := mload(add(signature, 0x20))\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                v := add(shr(255, vs), 27)\n            }\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/Diamond/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nlibrary LibDiamond {\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n  struct FacetAddressAndPosition {\n    address facetAddress;\n    uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n  }\n\n  struct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\n  }\n\n  struct DiamondStorage {\n    // maps function selector to the facet address and\n    // the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    // facet addresses\n    address[] facetAddresses;\n    // Used to query if a contract implements an interface.\n    // Used to implement ERC-165.\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address contractOwner;\n  }\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly { ds.slot := position }\n  }\n\n}\n"
    },
    "contracts/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n//\n\nlibrary LibAppStorage {\n  bytes32 constant STORAGE_SLOT = keccak256(\"app.storage\");\n\n  struct Layout {\n\n    address manager;\n    address opensea;\n    Counters.Counter totalSupply;\n    mapping (address => Counters.Counter) minterNonce;\n\n  }\n\n  function layout() internal pure returns (Layout storage l) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly { l.slot := slot }\n  }\n\n}\n"
    },
    "@solidstate/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n  function supportsInterface (\n    bytes4 interfaceId\n  ) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './ERC1155Base.sol';\n\nabstract contract ERC1155 is ERC1155Base {}\n"
    },
    "contracts/ERC1155URI/ERC1155URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary ERC1155URIStorage {\n  bytes32 internal constant STORAGE_SLOT = keccak256(\n    'diamond.storage.ERC1155URI'\n  );\n\n  struct Layout {\n    mapping (uint256 => string) tokenURIs;\n    string uri;\n  }\n\n  function layout() internal pure returns (Layout storage l) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly { l.slot := slot }\n  }\n\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// TODO: remove ERC165\n\nimport './IERC1155.sol';\nimport './IERC1155Receiver.sol';\nimport './ERC1155BaseStorage.sol';\nimport '../../introspection/ERC165.sol';\nimport '../../utils/AddressUtils.sol';\n\n/**\n * @title Base ERC1155 contract\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155Base is IERC1155, ERC165 {\n  using AddressUtils for address;\n\n  /**\n   * @notice query the balance of given token held by given address\n   * @param account address to query\n   * @param id token to query\n   * @return token balance\n   */\n  function balanceOf (\n    address account,\n    uint id\n  ) override public view returns (uint) {\n    require(account != address(0), 'ERC1155: balance query for the zero address');\n    return ERC1155BaseStorage.layout().balances[id][account];\n  }\n\n  /**\n   * @notice query the balances of given tokens held by given addresses\n   * @param accounts addresss to query\n   * @param ids tokens to query\n   * @return token balances\n   */\n  function balanceOfBatch (\n    address[] memory accounts,\n    uint[] memory ids\n  ) override public view returns (uint[] memory) {\n    require(accounts.length == ids.length, 'ERC1155: accounts and ids length mismatch');\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    uint[] memory batchBalances = new uint[](accounts.length);\n\n    for (uint i; i < accounts.length; i++) {\n      require(accounts[i] != address(0), 'ERC1155: batch balance query for the zero address');\n      batchBalances[i] = balances[ids[i]][accounts[i]];\n    }\n\n    return batchBalances;\n  }\n\n  /**\n   * @notice query approval status of given operator with respect to given address\n   * @param account address to query for approval granted\n   * @param operator address to query for approval received\n   * @return whether operator is approved to spend tokens held by account\n   */\n  function isApprovedForAll (\n    address account,\n    address operator\n  ) override public view returns (bool) {\n    return ERC1155BaseStorage.layout().operatorApprovals[account][operator];\n  }\n\n  /**\n   * @notice grant approval to or revoke approval from given operator to spend held tokens\n   * @param operator address whose approval status to update\n   * @param status whether operator should be considered approved\n   */\n  function setApprovalForAll (\n    address operator,\n    bool status\n  ) override public {\n    require(msg.sender != operator, 'ERC1155: setting approval status for self');\n    ERC1155BaseStorage.layout().operatorApprovals[msg.sender][operator] = status;\n    emit ApprovalForAll(msg.sender, operator, status);\n  }\n\n  /**\n   * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param id token ID\n   * @param amount quantity of tokens to transfer\n   * @param data data payload\n   */\n  function safeTransferFrom (\n    address from,\n    address to,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) override public {\n    require(from == msg.sender || isApprovedForAll(from, msg.sender), 'ERC1155: caller is not owner nor approved');\n    _safeTransfer(msg.sender, from, to, id, amount, data);\n  }\n\n  /**\n   * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param ids list of token IDs\n   * @param amounts list of quantities of tokens to transfer\n   * @param data data payload\n   */\n  function safeBatchTransferFrom (\n    address from,\n    address to,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) override public {\n    require(from == msg.sender || isApprovedForAll(from, msg.sender), 'ERC1155: caller is not owner nor approved');\n    _safeTransferBatch(msg.sender, from, to, ids, amounts, data);\n  }\n\n  /**\n   * @notice mint given quantity of tokens for given address\n   * @dev ERC1155Receiver implemenation is not checked\n   * @param account beneficiary of minting\n   * @param id token ID\n   * @param amount quantity of tokens to mint\n   * @param data data payload\n   */\n  function _mint (\n    address account,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) virtual internal {\n    require(account != address(0), 'ERC1155: mint to the zero address');\n\n    _beforeTokenTransfer(msg.sender, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n    mapping (address => uint) storage balances = ERC1155BaseStorage.layout().balances[id];\n    balances[account] += amount;\n\n    emit TransferSingle(msg.sender, address(0), account, id, amount);\n  }\n\n  /**\n   * @notice mint given quantity of tokens for given address\n   * @param account beneficiary of minting\n   * @param id token ID\n   * @param amount quantity of tokens to mint\n   * @param data data payload\n   */\n  function _safeMint (\n    address account,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) virtual internal {\n    _doSafeTransferAcceptanceCheck(msg.sender, address(0), account, id, amount, data);\n    _mint(account, id, amount, data);\n  }\n\n  /**\n   * @notice mint batch of tokens for given address\n   * @dev ERC1155Receiver implemenation is not checked\n   * @param account beneficiary of minting\n   * @param ids list of token IDs\n   * @param amounts list of quantities of tokens to mint\n   * @param data data payload\n   */\n  function _mintBatch (\n    address account,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {\n    require(account != address(0), 'ERC1155: mint to the zero address');\n    require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n\n    _beforeTokenTransfer(msg.sender, address(0), account, ids, amounts, data);\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    for (uint i; i < ids.length; i++) {\n      uint id = ids[i];\n      balances[id][account] += amounts[i];\n    }\n\n    emit TransferBatch(msg.sender, address(0), account, ids, amounts);\n  }\n\n  /**\n   * @notice mint batch of tokens for given address\n   * @param account beneficiary of minting\n   * @param ids list of token IDs\n   * @param amounts list of quantities of tokens to mint\n   * @param data data payload\n   */\n  function _safeMintBatch (\n    address account,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {\n    _doSafeBatchTransferAcceptanceCheck(msg.sender, address(0), account, ids, amounts, data);\n    _mintBatch(account, ids, amounts, data);\n  }\n\n  /**\n   * @notice burn given quantity of tokens held by given address\n   * @param account holder of tokens to burn\n   * @param id token ID\n   * @param amount quantity of tokens to burn\n   */\n  function _burn (\n    address account,\n    uint id,\n    uint amount\n  ) virtual internal {\n    require(account != address(0), 'ERC1155: burn from the zero address');\n\n    _beforeTokenTransfer(msg.sender, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), '');\n\n    mapping (address => uint) storage balances = ERC1155BaseStorage.layout().balances[id];\n    require(balances[account] >= amount, 'ERC1155: burn amount exceeds balances');\n    balances[account] -= amount;\n\n    emit TransferSingle(msg.sender, account, address(0), id, amount);\n  }\n\n  /**\n   * @notice burn given batch of tokens held by given address\n   * @param account holder of tokens to burn\n   * @param ids token IDs\n   * @param amounts quantities of tokens to burn\n   */\n  function _burnBatch (\n    address account,\n    uint[] memory ids,\n    uint[] memory amounts\n  ) virtual internal {\n    require(account != address(0), 'ERC1155: burn from the zero address');\n    require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n\n    _beforeTokenTransfer(msg.sender, account, address(0), ids, amounts, '');\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    for (uint i; i < ids.length; i++) {\n      uint id = ids[i];\n      require(balances[id][account] >= amounts[i], 'ERC1155: burn amount exceeds balance');\n      balances[id][account] -= amounts[i];\n    }\n\n    emit TransferBatch(msg.sender, account, address(0), ids, amounts);\n  }\n\n  /**\n   * @notice transfer tokens between given addresses\n   * @dev ERC1155Receiver implemenation is not checked\n   * @param operator executor of transfer\n   * @param sender sender of tokens\n   * @param recipient receiver of tokens\n   * @param id token ID\n   * @param amount quantity of tokens to transfer\n   * @param data data payload\n   */\n  function _transfer (\n    address operator,\n    address sender,\n    address recipient,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) virtual internal {\n    require(recipient != address(0), 'ERC1155: transfer to the zero address');\n\n    _beforeTokenTransfer(operator, sender, recipient, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    // TODO: error message\n    // balances[id][sender] = balances[id][sender].sub(amount, 'ERC1155: insufficient balances for transfer');\n    balances[id][sender] -= amount;\n    balances[id][recipient] += amount;\n\n    emit TransferSingle(operator, sender, recipient, id, amount);\n  }\n\n  /**\n   * @notice transfer tokens between given addresses\n   * @param operator executor of transfer\n   * @param sender sender of tokens\n   * @param recipient receiver of tokens\n   * @param id token ID\n   * @param amount quantity of tokens to transfer\n   * @param data data payload\n   */\n  function _safeTransfer (\n    address operator,\n    address sender,\n    address recipient,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) virtual internal {\n    _doSafeTransferAcceptanceCheck(operator, sender, recipient, id, amount, data);\n    _transfer(operator, sender, recipient, id, amount, data);\n  }\n\n  /**\n   * @notice transfer batch of tokens between given addresses\n   * @dev ERC1155Receiver implemenation is not checked\n   * @param operator executor of transfer\n   * @param sender sender of tokens\n   * @param recipient receiver of tokens\n   * @param ids token IDs\n   * @param amounts quantities of tokens to transfer\n   * @param data data payload\n   */\n  function _transferBatch (\n    address operator,\n    address sender,\n    address recipient,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {\n    require(recipient != address(0), 'ERC1155: transfer to the zero address');\n    require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n\n    _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    for (uint i; i < ids.length; i++) {\n      uint token = ids[i];\n      uint amount = amounts[i];\n      // TODO: error message\n      // balances[id][sender] = balances[id][sender].sub(amount, 'ERC1155: insufficient balances for transfer');\n      balances[token][sender] -= amount;\n      balances[token][recipient] += amount;\n    }\n\n    emit TransferBatch(operator, sender, recipient, ids, amounts);\n  }\n\n  /**\n   * @notice transfer batch of tokens between given addresses\n   * @param operator executor of transfer\n   * @param sender sender of tokens\n   * @param recipient receiver of tokens\n   * @param ids token IDs\n   * @param amounts quantities of tokens to transfer\n   * @param data data payload\n   */\n  function _safeTransferBatch (\n    address operator,\n    address sender,\n    address recipient,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {\n    _doSafeBatchTransferAcceptanceCheck(operator, sender, recipient, ids, amounts, data);\n    _transferBatch(operator, sender, recipient, ids, amounts, data);\n  }\n\n  /**\n   * @notice wrap given element in array of length 1\n   * @param element element to wrap\n   * @return singleton array\n   */\n  function _asSingletonArray (\n    uint element\n  ) private pure returns (uint[] memory) {\n    uint[] memory array = new uint[](1);\n    array[0] = element;\n    return array;\n  }\n\n  /**\n   * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n   * @param operator executor of transfer\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param id token ID\n   * @param amount quantity of tokens to transfer\n   * @param data data payload\n   */\n  function _doSafeTransferAcceptanceCheck (\n    address operator,\n    address from,\n    address to,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) private {\n    if (to.isContract()) {\n      try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n        require(\n          response == IERC1155Receiver.onERC1155Received.selector,\n          'ERC1155: ERC1155Receiver rejected tokens'\n        );\n      } catch Error(string memory reason) {\n        revert(reason);\n      } catch {\n        revert('ERC1155: transfer to non ERC1155Receiver implementer');\n      }\n    }\n  }\n\n  /**\n  * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n   * @param operator executor of transfer\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param ids token IDs\n   * @param amounts quantities of tokens to transfer\n   * @param data data payload\n   */\n  function _doSafeBatchTransferAcceptanceCheck (\n    address operator,\n    address from,\n    address to,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) private {\n    if (to.isContract()) {\n      try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n        require(\n          response == IERC1155Receiver.onERC1155BatchReceived.selector,\n          'ERC1155: ERC1155Receiver rejected tokens'\n        );\n      } catch Error(string memory reason) {\n        revert(reason);\n      } catch {\n        revert('ERC1155: transfer to non ERC1155Receiver implementer');\n      }\n    }\n  }\n\n  /**\n   * @notice ERC1155 hook, called before all transfers including mint and burn\n   * @dev function should be overridden and new implemenation must call super\n   * @dev called for both single and batch transfers\n   * @param operator executor of transfer\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param ids token IDs\n   * @param amounts quantities of tokens to transfer\n   * @param data data payload\n   */\n  function _beforeTokenTransfer (\n    address operator,\n    address from,\n    address to,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {}\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '../../introspection/IERC165.sol';\n\ninterface IERC1155Receiver is IERC165 {\n  function onERC1155Received (\n    address operator,\n    address from,\n    uint256 id,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bytes4);\n\n  function onERC1155BatchReceived (\n    address operator,\n    address from,\n    uint256[] calldata ids,\n    uint256[] calldata values,\n    bytes calldata data\n  ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/ERC1155BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC1155BaseStorage {\n  bytes32 internal constant STORAGE_SLOT = keccak256(\n    'solidstate.contracts.storage.ERC1155Base'\n  );\n\n  struct Layout {\n    mapping (uint => mapping (address => uint)) balances;\n    mapping (address => mapping (address => bool)) operatorApprovals;\n  }\n\n  function layout () internal pure returns (Layout storage l) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly { l.slot := slot }\n  }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC165.sol';\nimport './ERC165Storage.sol';\n\nabstract contract ERC165 is IERC165 {\n  using ERC165Storage for ERC165Storage.Layout;\n\n  function supportsInterface (bytes4 interfaceId) override public view returns (bool) {\n    return ERC165Storage.layout().isSupportedInterface(interfaceId);\n  }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n  function toString (address account) internal pure returns (string memory) {\n    bytes32 value = bytes32(uint256(uint160(account)));\n    bytes memory alphabet = '0123456789abcdef';\n    bytes memory chars = new bytes(42);\n\n    chars[0] = '0';\n    chars[1] = 'x';\n\n    for (uint256 i = 0; i < 20; i++) {\n      chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n      chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n    }\n\n    return string(chars);\n  }\n\n  function isContract (address account) internal view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n\n  function sendValue (address payable account, uint amount) internal {\n    (bool success, ) = account.call{ value: amount }('');\n    require(success, 'AddressUtils: failed to send value');\n  }\n\n  function functionCall (address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, 'AddressUtils: failed low-level call');\n  }\n\n  function functionCall (address target, bytes memory data, string memory error) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, error);\n  }\n\n  function functionCallWithValue (address target, bytes memory data, uint value) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, 'AddressUtils: failed low-level call with value');\n  }\n\n  function functionCallWithValue (address target, bytes memory data, uint value, string memory error) internal returns (bytes memory) {\n    require(address(this).balance >= value, 'AddressUtils: insufficient balance for call');\n    return _functionCallWithValue(target, data, value, error);\n  }\n\n  function _functionCallWithValue (address target, bytes memory data, uint value, string memory error) private returns (bytes memory) {\n    require(isContract(target), 'AddressUtils: function call to non-contract');\n\n    (bool success, bytes memory returnData) = target.call{ value: value }(data);\n\n    if (success) {\n      return returnData;\n    } else if (returnData.length > 0) {\n      assembly {\n        let returnData_size := mload(returnData)\n        revert(add(32, returnData), returnData_size)\n      }\n    } else {\n      revert(error);\n    }\n  }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC165Storage {\n  bytes32 internal constant STORAGE_SLOT = keccak256(\n    'solidstate.contracts.storage.ERC165'\n  );\n\n  struct Layout {\n    // TODO: use EnumerableSet to allow post-diamond-cut auditing\n    mapping (bytes4 => bool) supportedInterfaces;\n  }\n\n  function layout () internal pure returns (Layout storage l) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly { l.slot := slot }\n  }\n\n  function isSupportedInterface (\n    Layout storage l,\n    bytes4 interfaceId\n  ) internal view returns (bool) {\n    return l.supportedInterfaces[interfaceId];\n  }\n\n  function setSupportedInterface (\n    Layout storage l,\n    bytes4 interfaceId,\n    bool status\n  ) internal {\n    require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\n    l.supportedInterfaces[interfaceId] = status;\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}