{
  "language": "Solidity",
  "sources": {
    "contracts/BaseRelayRecipient/BaseRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport './BaseRelayRecipientStorage.sol';\n\n/**\n * A base contract to be inherited by any contract that want to receive relayed transactions\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\n */\n\nabstract contract BaseRelayRecipient is Context {\n  /*\n   * require a function to be called through GSN only\n   */\n  //  modifier trustedForwarderOnly() {\n  //    require(msg.sender == address(s.trustedForwarder), \"Function can only be called through the trusted Forwarder\");\n  //    _;\n  //  }\n\n  function isTrustedForwarder(address forwarder) public view returns (bool) {\n    return forwarder == BaseRelayRecipientStorage.layout().trustedForwarder;\n  }\n\n  /**\n   * return the sender of this call.\n   * if the call came through our trusted forwarder, return the original sender.\n   * otherwise, return `msg.sender`.\n   * should be used in the contract anywhere instead of msg.sender\n   */\n  function _msgSender() internal view virtual override returns (address ret) {\n    if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n      // At this point we know that the sender is a trusted forwarder,\n      // so we trust that the last bytes of msg.data are the verified sender address.\n      // extract sender address from the end of msg.data\n      assembly {\n        ret := shr(96, calldataload(sub(calldatasize(), 20)))\n      }\n    } else {\n      return msg.sender;\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/BaseRelayRecipient/BaseRelayRecipientStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\nlibrary BaseRelayRecipientStorage {\n  bytes32 internal constant STORAGE_SLOT =\n    keccak256('diamond.storage.BaseRelayRecipientStorage');\n\n  struct Layout {\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address trustedForwarder;\n  }\n\n  function layout() internal pure returns (Layout storage layout) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly {\n      layout.slot := slot\n    }\n  }\n}\n"
    },
    "contracts/CyberDestinationFactoryBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n//\nimport '@solidstate/contracts/token/ERC1155/IERC1155.sol';\nimport './ERC1155URI/ERC1155URI.sol';\nimport './BaseRelayRecipient/BaseRelayRecipient.sol';\n\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport './Diamond/LibDiamond.sol';\nimport './BaseRelayRecipient/BaseRelayRecipientStorage.sol';\nimport './libraries/LibAppStorage.sol';\n\ncontract CyberDestinationFactoryBase is BaseRelayRecipient, ERC1155URI {\n  using ECDSA for bytes32;\n  using Counters for Counters.Counter;\n\n  event Minted(\n    address indexed account,\n    uint256 indexed tokenId,\n    uint256 indexed amount\n  );\n\n  function initialize(\n    string memory _uri,\n    address _manager,\n    address _trustedForwarder,\n    address _opensea,\n    address _oncyber\n  ) public virtual {\n    require(LibDiamond.diamondStorage().contractOwner == msg.sender, 'NO');\n\n    BaseRelayRecipientStorage.layout().trustedForwarder = _trustedForwarder;\n    LibDiamond.diamondStorage().supportedInterfaces[\n      type(IERC1155).interfaceId\n    ] = true;\n    setURI(_uri);\n    LibAppStorage.layout().manager = _manager;\n    LibAppStorage.layout().opensea = _opensea;\n    LibAppStorage.layout().oncyber = _oncyber;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return LibAppStorage.layout().totalSupply.current();\n  }\n\n  function manager() public view returns (address) {\n    return LibAppStorage.layout().manager;\n  }\n\n  function oncyber() public view returns (address) {\n    return LibAppStorage.layout().oncyber;\n  }\n\n  function minterNonce(address _minter) public view returns (uint256) {\n    return LibAppStorage.layout().minterNonce[_minter].current();\n  }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC1155Internal} from './IERC1155Internal.sol';\nimport {IERC165} from '../../introspection/IERC165.sol';\n\n/**\n * @notice ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n  /**\n   * @notice query the balance of given token held by given address\n   * @param account address to query\n   * @param id token to query\n   * @return token balance\n   */\n  function balanceOf (\n    address account,\n    uint256 id\n  ) external view returns (uint256);\n\n  /**\n   * @notice query the balances of given tokens held by given addresses\n   * @param accounts addresss to query\n   * @param ids tokens to query\n   * @return token balances\n   */\n  function balanceOfBatch (\n    address[] calldata accounts,\n    uint256[] calldata ids\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @notice query approval status of given operator with respect to given address\n   * @param account address to query for approval granted\n   * @param operator address to query for approval received\n   * @return whether operator is approved to spend tokens held by account\n   */\n  function isApprovedForAll (\n    address account,\n    address operator\n  ) external view returns (bool);\n\n  /**\n   * @notice grant approval to or revoke approval from given operator to spend held tokens\n   * @param operator address whose approval status to update\n   * @param status whether operator should be considered approved\n   */\n  function setApprovalForAll (\n    address operator,\n    bool status\n  ) external;\n\n  /**\n   * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param id token ID\n   * @param amount quantity of tokens to transfer\n   * @param data data payload\n   */\n  function safeTransferFrom (\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  /**\n   * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param ids list of token IDs\n   * @param amounts list of quantities of tokens to transfer\n   * @param data data payload\n   */\n  function safeBatchTransferFrom (\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/ERC1155URI/ERC1155URI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\nimport '@solidstate/contracts/token/ERC1155/ERC1155.sol';\nimport './ERC1155URIStorage.sol';\n\nabstract contract ERC1155URI is ERC1155 {\n  function uri(uint256 _tokenId) public view virtual returns (string memory) {\n    string memory tokenURI = ERC1155URIStorage.layout().tokenURIs[_tokenId];\n    require(bytes(tokenURI).length != 0, 'ERC1155URI: tokenId not exist');\n    return string(abi.encodePacked(ERC1155URIStorage.layout().uri, tokenURI));\n  }\n\n  function setURI(string memory newUri) internal virtual {\n    ERC1155URIStorage.layout().uri = newUri;\n  }\n\n  function setTokenURI(uint256 tokenId, string memory _tokenURI)\n    internal\n    virtual\n  {\n    ERC1155URIStorage.layout().tokenURIs[tokenId] = _tokenURI;\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/Diamond/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nlibrary LibDiamond {\n  bytes32 public constant DIAMOND_STORAGE_POSITION =\n    keccak256('diamond.standard.diamond.storage');\n\n  struct FacetAddressAndPosition {\n    address facetAddress;\n    uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n  }\n\n  struct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\n  }\n\n  struct DiamondStorage {\n    // maps function selector to the facet address and\n    // the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    // facet addresses\n    address[] facetAddresses;\n    // Used to query if a contract implements an interface.\n    // Used to implement ERC-165.\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address contractOwner;\n  }\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n}\n"
    },
    "contracts/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\nimport '@openzeppelin/contracts/utils/Counters.sol';\n\n//\n\nlibrary LibAppStorage {\n  bytes32 public constant STORAGE_SLOT = keccak256('app.storage');\n\n  struct Layout {\n    address manager;\n    address opensea;\n    Counters.Counter totalSupply;\n    mapping(address => Counters.Counter) minterNonce;\n    address oncyber;\n  }\n\n  function layout() internal pure returns (Layout storage layout) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly {\n      layout.slot := slot\n    }\n  }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC165} from '../../introspection/IERC165.sol';\n\n/**\n * @notice Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n  event TransferSingle (\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256 id,\n    uint256 value\n  );\n\n  event TransferBatch (\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256[] ids,\n    uint256[] values\n  );\n\n  event ApprovalForAll (\n    address indexed account,\n    address indexed operator,\n    bool approved\n  );\n\n  event URI (\n    string value,\n    uint256 indexed id\n  );\n}\n"
    },
    "@solidstate/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n  /**\n   * @notice query whether contract has registered support for given interface\n   * @param interfaceId interface id\n   * @return bool whether interface is supported\n   */\n  function supportsInterface (\n    bytes4 interfaceId\n  ) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ERC165} from '../../introspection/ERC165.sol';\nimport {ERC1155Base} from './base/ERC1155Base.sol';\n\n/**\n * @title SolidState ERC1155 implementation\n */\nabstract contract ERC1155 is ERC1155Base, ERC165 {}\n"
    },
    "contracts/ERC1155URI/ERC1155URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\nlibrary ERC1155URIStorage {\n  bytes32 internal constant STORAGESLOT =\n    keccak256('diamond.storage.ERC1155URI');\n\n  struct Layout {\n    mapping(uint256 => string) tokenURIs;\n    string uri;\n  }\n\n  function layout() internal pure returns (Layout storage layout) {\n    bytes32 slot = STORAGESLOT;\n    assembly {\n      layout.slot := slot\n    }\n  }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC165} from './IERC165.sol';\nimport {ERC165Storage} from './ERC165Storage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165 is IERC165 {\n  using ERC165Storage for ERC165Storage.Layout;\n\n  /**\n   * @inheritdoc IERC165\n   */\n  function supportsInterface (bytes4 interfaceId) override public view returns (bool) {\n    return ERC165Storage.layout().isSupportedInterface(interfaceId);\n  }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC1155} from '../IERC1155.sol';\nimport {IERC1155Receiver} from '../IERC1155Receiver.sol';\nimport {ERC1155BaseInternal, ERC1155BaseStorage} from './ERC1155BaseInternal.sol';\n\n/**\n * @title Base ERC1155 contract\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155Base is IERC1155, ERC1155BaseInternal {\n  /**\n   * @inheritdoc IERC1155\n   */\n  function balanceOf (\n    address account,\n    uint id\n  ) virtual override public view returns (uint) {\n    return _balanceOf(account, id);\n  }\n\n  /**\n   * @inheritdoc IERC1155\n   */\n  function balanceOfBatch (\n    address[] memory accounts,\n    uint[] memory ids\n  ) virtual override public view returns (uint[] memory) {\n    require(accounts.length == ids.length, 'ERC1155: accounts and ids length mismatch');\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    uint[] memory batchBalances = new uint[](accounts.length);\n\n    unchecked {\n      for (uint i; i < accounts.length; i++) {\n        require(accounts[i] != address(0), 'ERC1155: batch balance query for the zero address');\n        batchBalances[i] = balances[ids[i]][accounts[i]];\n      }\n    }\n\n    return batchBalances;\n  }\n\n  /**\n   * @inheritdoc IERC1155\n   */\n  function isApprovedForAll (\n    address account,\n    address operator\n  ) virtual override public view returns (bool) {\n    return ERC1155BaseStorage.layout().operatorApprovals[account][operator];\n  }\n\n  /**\n   * @inheritdoc IERC1155\n   */\n  function setApprovalForAll (\n    address operator,\n    bool status\n  ) virtual override public {\n    require(msg.sender != operator, 'ERC1155: setting approval status for self');\n    ERC1155BaseStorage.layout().operatorApprovals[msg.sender][operator] = status;\n    emit ApprovalForAll(msg.sender, operator, status);\n  }\n\n  /**\n   * @inheritdoc IERC1155\n   */\n  function safeTransferFrom (\n    address from,\n    address to,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) virtual override public {\n    require(from == msg.sender || isApprovedForAll(from, msg.sender), 'ERC1155: caller is not owner nor approved');\n    _safeTransfer(msg.sender, from, to, id, amount, data);\n  }\n\n  /**\n   * @inheritdoc IERC1155\n   */\n  function safeBatchTransferFrom (\n    address from,\n    address to,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual override public {\n    require(from == msg.sender || isApprovedForAll(from, msg.sender), 'ERC1155: caller is not owner nor approved');\n    _safeTransferBatch(msg.sender, from, to, ids, amounts, data);\n  }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC165Storage {\n  struct Layout {\n    // TODO: use EnumerableSet to allow post-diamond-cut auditing\n    mapping (bytes4 => bool) supportedInterfaces;\n  }\n\n  bytes32 internal constant STORAGE_SLOT = keccak256(\n    'solidstate.contracts.storage.ERC165'\n  );\n\n  function layout () internal pure returns (Layout storage l) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly { l.slot := slot }\n  }\n\n  function isSupportedInterface (\n    Layout storage l,\n    bytes4 interfaceId\n  ) internal view returns (bool) {\n    return l.supportedInterfaces[interfaceId];\n  }\n\n  function setSupportedInterface (\n    Layout storage l,\n    bytes4 interfaceId,\n    bool status\n  ) internal {\n    require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\n    l.supportedInterfaces[interfaceId] = status;\n  }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC165} from '../../introspection/IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n  /**\n   * @notice validate receipt of ERC1155 transfer\n   * @param operator executor of transfer\n   * @param from sender of tokens\n   * @param id token ID received\n   * @param value quantity of tokens received\n   * @param data data payload\n   * @return function's own selector if transfer is accepted\n   */\n  function onERC1155Received (\n    address operator,\n    address from,\n    uint256 id,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bytes4);\n\n  /**\n   * @notice validate receipt of ERC1155 batch transfer\n   * @param operator executor of transfer\n   * @param from sender of tokens\n   * @param ids token IDs received\n   * @param values quantities of tokens received\n   * @param data data payload\n   * @return function's own selector if transfer is accepted\n   */\n  function onERC1155BatchReceived (\n    address operator,\n    address from,\n    uint256[] calldata ids,\n    uint256[] calldata values,\n    bytes calldata data\n  ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {AddressUtils} from '../../../utils/AddressUtils.sol';\nimport {IERC1155Internal} from '../IERC1155Internal.sol';\nimport {IERC1155Receiver} from '../IERC1155Receiver.sol';\nimport {ERC1155BaseStorage} from './ERC1155BaseStorage.sol';\n\n/**\n * @title Base ERC1155 internal functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155BaseInternal is IERC1155Internal {\n  using AddressUtils for address;\n\n  /**\n   * @notice query the balance of given token held by given address\n   * @param account address to query\n   * @param id token to query\n   * @return token balance\n   */\n  function _balanceOf (\n    address account,\n    uint id\n  ) virtual internal view returns (uint) {\n    require(account != address(0), 'ERC1155: balance query for the zero address');\n    return ERC1155BaseStorage.layout().balances[id][account];\n  }\n\n  /**\n   * @notice mint given quantity of tokens for given address\n   * @dev ERC1155Receiver implementation is not checked\n   * @param account beneficiary of minting\n   * @param id token ID\n   * @param amount quantity of tokens to mint\n   * @param data data payload\n   */\n  function _mint (\n    address account,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) virtual internal {\n    require(account != address(0), 'ERC1155: mint to the zero address');\n\n    _beforeTokenTransfer(msg.sender, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n    mapping (address => uint) storage balances = ERC1155BaseStorage.layout().balances[id];\n    balances[account] += amount;\n\n    emit TransferSingle(msg.sender, address(0), account, id, amount);\n  }\n\n  /**\n   * @notice mint given quantity of tokens for given address\n   * @param account beneficiary of minting\n   * @param id token ID\n   * @param amount quantity of tokens to mint\n   * @param data data payload\n   */\n  function _safeMint (\n    address account,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) virtual internal {\n    _doSafeTransferAcceptanceCheck(msg.sender, address(0), account, id, amount, data);\n    _mint(account, id, amount, data);\n  }\n\n  /**\n   * @notice mint batch of tokens for given address\n   * @dev ERC1155Receiver implementation is not checked\n   * @param account beneficiary of minting\n   * @param ids list of token IDs\n   * @param amounts list of quantities of tokens to mint\n   * @param data data payload\n   */\n  function _mintBatch (\n    address account,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {\n    require(account != address(0), 'ERC1155: mint to the zero address');\n    require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n\n    _beforeTokenTransfer(msg.sender, address(0), account, ids, amounts, data);\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    for (uint i; i < ids.length; i++) {\n      balances[ids[i]][account] += amounts[i];\n    }\n\n    emit TransferBatch(msg.sender, address(0), account, ids, amounts);\n  }\n\n  /**\n   * @notice mint batch of tokens for given address\n   * @param account beneficiary of minting\n   * @param ids list of token IDs\n   * @param amounts list of quantities of tokens to mint\n   * @param data data payload\n   */\n  function _safeMintBatch (\n    address account,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {\n    _doSafeBatchTransferAcceptanceCheck(msg.sender, address(0), account, ids, amounts, data);\n    _mintBatch(account, ids, amounts, data);\n  }\n\n  /**\n   * @notice burn given quantity of tokens held by given address\n   * @param account holder of tokens to burn\n   * @param id token ID\n   * @param amount quantity of tokens to burn\n   */\n  function _burn (\n    address account,\n    uint id,\n    uint amount\n  ) virtual internal {\n    require(account != address(0), 'ERC1155: burn from the zero address');\n\n    _beforeTokenTransfer(msg.sender, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), '');\n\n    mapping (address => uint) storage balances = ERC1155BaseStorage.layout().balances[id];\n\n    unchecked {\n      require(balances[account] >= amount, 'ERC1155: burn amount exceeds balances');\n      balances[account] -= amount;\n    }\n\n    emit TransferSingle(msg.sender, account, address(0), id, amount);\n  }\n\n  /**\n   * @notice burn given batch of tokens held by given address\n   * @param account holder of tokens to burn\n   * @param ids token IDs\n   * @param amounts quantities of tokens to burn\n   */\n  function _burnBatch (\n    address account,\n    uint[] memory ids,\n    uint[] memory amounts\n  ) virtual internal {\n    require(account != address(0), 'ERC1155: burn from the zero address');\n    require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n\n    _beforeTokenTransfer(msg.sender, account, address(0), ids, amounts, '');\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    unchecked {\n      for (uint i; i < ids.length; i++) {\n        uint id = ids[i];\n        require(balances[id][account] >= amounts[i], 'ERC1155: burn amount exceeds balance');\n        balances[id][account] -= amounts[i];\n      }\n    }\n\n    emit TransferBatch(msg.sender, account, address(0), ids, amounts);\n  }\n\n  /**\n   * @notice transfer tokens between given addresses\n   * @dev ERC1155Receiver implementation is not checked\n   * @param operator executor of transfer\n   * @param sender sender of tokens\n   * @param recipient receiver of tokens\n   * @param id token ID\n   * @param amount quantity of tokens to transfer\n   * @param data data payload\n   */\n  function _transfer (\n    address operator,\n    address sender,\n    address recipient,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) virtual internal {\n    require(recipient != address(0), 'ERC1155: transfer to the zero address');\n\n    _beforeTokenTransfer(operator, sender, recipient, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    unchecked {\n      uint256 senderBalance = balances[id][sender];\n      require(senderBalance >= amount, 'ERC1155: insufficient balances for transfer');\n      balances[id][sender] = senderBalance - amount;\n    }\n\n    balances[id][recipient] += amount;\n\n    emit TransferSingle(operator, sender, recipient, id, amount);\n  }\n\n  /**\n   * @notice transfer tokens between given addresses\n   * @param operator executor of transfer\n   * @param sender sender of tokens\n   * @param recipient receiver of tokens\n   * @param id token ID\n   * @param amount quantity of tokens to transfer\n   * @param data data payload\n   */\n  function _safeTransfer (\n    address operator,\n    address sender,\n    address recipient,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) virtual internal {\n    _doSafeTransferAcceptanceCheck(operator, sender, recipient, id, amount, data);\n    _transfer(operator, sender, recipient, id, amount, data);\n  }\n\n  /**\n   * @notice transfer batch of tokens between given addresses\n   * @dev ERC1155Receiver implementation is not checked\n   * @param operator executor of transfer\n   * @param sender sender of tokens\n   * @param recipient receiver of tokens\n   * @param ids token IDs\n   * @param amounts quantities of tokens to transfer\n   * @param data data payload\n   */\n  function _transferBatch (\n    address operator,\n    address sender,\n    address recipient,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {\n    require(recipient != address(0), 'ERC1155: transfer to the zero address');\n    require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n\n    _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\n\n    mapping (uint => mapping (address => uint)) storage balances = ERC1155BaseStorage.layout().balances;\n\n    for (uint i; i < ids.length; i++) {\n      uint token = ids[i];\n      uint amount = amounts[i];\n\n      unchecked {\n        uint256 senderBalance = balances[token][sender];\n        require(senderBalance >= amount, 'ERC1155: insufficient balances for transfer');\n        balances[token][sender] = senderBalance - amount;\n      }\n\n      balances[token][recipient] += amount;\n    }\n\n    emit TransferBatch(operator, sender, recipient, ids, amounts);\n  }\n\n  /**\n   * @notice transfer batch of tokens between given addresses\n   * @param operator executor of transfer\n   * @param sender sender of tokens\n   * @param recipient receiver of tokens\n   * @param ids token IDs\n   * @param amounts quantities of tokens to transfer\n   * @param data data payload\n   */\n  function _safeTransferBatch (\n    address operator,\n    address sender,\n    address recipient,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {\n    _doSafeBatchTransferAcceptanceCheck(operator, sender, recipient, ids, amounts, data);\n    _transferBatch(operator, sender, recipient, ids, amounts, data);\n  }\n\n  /**\n   * @notice wrap given element in array of length 1\n   * @param element element to wrap\n   * @return singleton array\n   */\n  function _asSingletonArray (\n    uint element\n  ) private pure returns (uint[] memory) {\n    uint[] memory array = new uint[](1);\n    array[0] = element;\n    return array;\n  }\n\n  /**\n   * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n   * @param operator executor of transfer\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param id token ID\n   * @param amount quantity of tokens to transfer\n   * @param data data payload\n   */\n  function _doSafeTransferAcceptanceCheck (\n    address operator,\n    address from,\n    address to,\n    uint id,\n    uint amount,\n    bytes memory data\n  ) private {\n    if (to.isContract()) {\n      try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n        require(\n          response == IERC1155Receiver.onERC1155Received.selector,\n          'ERC1155: ERC1155Receiver rejected tokens'\n        );\n      } catch Error(string memory reason) {\n        revert(reason);\n      } catch {\n        revert('ERC1155: transfer to non ERC1155Receiver implementer');\n      }\n    }\n  }\n\n  /**\n  * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n   * @param operator executor of transfer\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param ids token IDs\n   * @param amounts quantities of tokens to transfer\n   * @param data data payload\n   */\n  function _doSafeBatchTransferAcceptanceCheck (\n    address operator,\n    address from,\n    address to,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) private {\n    if (to.isContract()) {\n      try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n        require(\n          response == IERC1155Receiver.onERC1155BatchReceived.selector,\n          'ERC1155: ERC1155Receiver rejected tokens'\n        );\n      } catch Error(string memory reason) {\n        revert(reason);\n      } catch {\n        revert('ERC1155: transfer to non ERC1155Receiver implementer');\n      }\n    }\n  }\n\n  /**\n   * @notice ERC1155 hook, called before all transfers including mint and burn\n   * @dev function should be overridden and new implementation must call super\n   * @dev called for both single and batch transfers\n   * @param operator executor of transfer\n   * @param from sender of tokens\n   * @param to receiver of tokens\n   * @param ids token IDs\n   * @param amounts quantities of tokens to transfer\n   * @param data data payload\n   */\n  function _beforeTokenTransfer (\n    address operator,\n    address from,\n    address to,\n    uint[] memory ids,\n    uint[] memory amounts,\n    bytes memory data\n  ) virtual internal {}\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n  function toString (address account) internal pure returns (string memory) {\n    bytes32 value = bytes32(uint256(uint160(account)));\n    bytes memory alphabet = '0123456789abcdef';\n    bytes memory chars = new bytes(42);\n\n    chars[0] = '0';\n    chars[1] = 'x';\n\n    for (uint256 i = 0; i < 20; i++) {\n      chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n      chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n    }\n\n    return string(chars);\n  }\n\n  function isContract (address account) internal view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n\n  function sendValue (address payable account, uint amount) internal {\n    (bool success, ) = account.call{ value: amount }('');\n    require(success, 'AddressUtils: failed to send value');\n  }\n\n  function functionCall (address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, 'AddressUtils: failed low-level call');\n  }\n\n  function functionCall (address target, bytes memory data, string memory error) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, error);\n  }\n\n  function functionCallWithValue (address target, bytes memory data, uint value) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, 'AddressUtils: failed low-level call with value');\n  }\n\n  function functionCallWithValue (address target, bytes memory data, uint value, string memory error) internal returns (bytes memory) {\n    require(address(this).balance >= value, 'AddressUtils: insufficient balance for call');\n    return _functionCallWithValue(target, data, value, error);\n  }\n\n  function _functionCallWithValue (address target, bytes memory data, uint value, string memory error) private returns (bytes memory) {\n    require(isContract(target), 'AddressUtils: function call to non-contract');\n\n    (bool success, bytes memory returnData) = target.call{ value: value }(data);\n\n    if (success) {\n      return returnData;\n    } else if (returnData.length > 0) {\n      assembly {\n        let returnData_size := mload(returnData)\n        revert(add(32, returnData), returnData_size)\n      }\n    } else {\n      revert(error);\n    }\n  }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC1155BaseStorage {\n  struct Layout {\n    mapping (uint => mapping (address => uint)) balances;\n    mapping (address => mapping (address => bool)) operatorApprovals;\n  }\n\n  bytes32 internal constant STORAGE_SLOT = keccak256(\n    'solidstate.contracts.storage.ERC1155Base'\n  );\n\n  function layout () internal pure returns (Layout storage l) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly { l.slot := slot }\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/DestinationUtility/CyberDestinationUtilityFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n//\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport '../CyberDestinationFactoryBase.sol';\nimport '../libraries/LibAppStorage.sol';\nimport './LibUtilityStorage.sol';\n\ncontract CyberDestinationUtilityFactoryFacet is CyberDestinationFactoryBase {\n  using ECDSA for bytes32;\n  using Counters for Counters.Counter;\n\n  event DestinationMinted(\n    address indexed account,\n    uint256 indexed tokenId\n  );\n\n  function getDrop(uint256 _tokenId)\n    public\n    view\n    returns (LibUtilityStorage.Drop memory)\n  {\n    LibUtilityStorage.Drop memory drop = LibUtilityStorage.layout().drops[\n      _tokenId\n    ];\n    require(drop.timeStart != 0, 'DNE');\n\n    return drop;\n  }\n\n  function mint(\n    string memory _uri,\n    uint256 _timeStart,\n    uint256 _timeEnd,\n    uint256 _price,\n    uint256 _amountCap,\n    uint256 _shareCyber,\n    bytes memory _signature\n  ) public returns (uint256 _tokenId) {\n    address sender = _msgSender();\n    uint256 nonce = minterNonce(sender);\n    require(_shareCyber <= 100, 'ISO');\n    require(_timeStart < _timeEnd, 'IT');\n\n    bytes memory _message = abi.encodePacked(\n      _uri,\n      _timeStart,\n      _timeEnd,\n      _price,\n      _amountCap,\n      _shareCyber,\n      nonce,\n      sender\n    );\n    address recoveredAddress = keccak256(_message)\n      .toEthSignedMessageHash()\n      .recover(_signature);\n    require(recoveredAddress == LibAppStorage.layout().manager, 'NM');\n\n    // Mint token\n    _tokenId = LibAppStorage.layout().totalSupply.current();\n    setTokenURI(_tokenId, _uri);\n    LibAppStorage.layout().totalSupply.increment();\n    LibAppStorage.layout().minterNonce[sender].increment();\n    LibUtilityStorage.Drop memory drop = LibUtilityStorage.Drop({\n      timeStart: _timeStart,\n      timeEnd: _timeEnd,\n      amountCap: _amountCap,\n      shareCyber: _shareCyber,\n      creator: payable(sender),\n      price: _price,\n      minted: 0\n    });\n    LibUtilityStorage.layout().drops[_tokenId] = drop;\n\n    emit DestinationMinted(sender, _tokenId);\n\n\n    return _tokenId;\n  }\n\n  function mintEdition(uint256 _tokenId) public payable returns (bool) {\n    address sender = _msgSender();\n    LibUtilityStorage.Drop storage drop = LibUtilityStorage.layout().drops[\n      _tokenId\n    ];\n    \n    require(\n      block.timestamp >= drop.timeStart && block.timestamp <= drop.timeEnd,\n      'OOT'\n    );\n\n    require(msg.value == drop.price, 'IA');\n    \n    if (drop.amountCap != 0) {\n      require(drop.minted < drop.amountCap, 'CR');\n    }\n\n    _safeMint(sender, _tokenId, 1, '');\n    drop.minted += 1;\n    emit Minted(sender, _tokenId, 1);\n\n    uint256 amountOnCyber = (msg.value * drop.shareCyber) / 100;\n    uint256 amountCreator = msg.value - amountOnCyber;\n\n    drop.creator.transfer(amountCreator);\n    payable(LibAppStorage.layout().oncyber).transfer(amountOnCyber);\n    return true;\n  }\n}\n"
    },
    "contracts/DestinationUtility/LibUtilityStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\n//\n\nlibrary LibUtilityStorage {\n  bytes32 public constant STORAGE_SLOT = keccak256('utility.app.storage');\n  struct Drop {\n    uint256 timeStart;\n    uint256 timeEnd;\n    uint256 shareCyber;\n    uint256 price;\n    uint256 amountCap;\n    uint256 minted;\n    address payable creator;\n  }\n\n  struct Layout {\n    mapping(uint256 => Drop) drops;\n  }\n\n  function layout() internal pure returns (Layout storage layout) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly {\n      layout.slot := slot\n    }\n  }\n}\n"
    },
    "contracts/Destination/CyberDestinationFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n//\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport '../CyberDestinationFactoryBase.sol';\n\ncontract CyberDestinationFactoryFacet is CyberDestinationFactoryBase {\n  using ECDSA for bytes32;\n  using Counters for Counters.Counter;\n\n  function mint(\n    string memory _uri,\n    uint256 _amount,\n    uint256 _amountOncyber,\n    bytes memory _signature\n  ) public returns (uint256 _tokenId) {\n    address sender = _msgSender();\n    uint256 nonce = minterNonce(sender);\n\n    bytes memory _message = abi.encodePacked(\n      _uri,\n      _amount,\n      _amountOncyber,\n      nonce,\n      sender\n    );\n    address recoveredAddress = keccak256(_message)\n      .toEthSignedMessageHash()\n      .recover(_signature);\n    require(recoveredAddress == LibAppStorage.layout().manager, 'NM');\n    require(_amount >= _amountOncyber, 'IAO');\n\n    // Mint token\n    _tokenId = LibAppStorage.layout().totalSupply.current();\n    setTokenURI(_tokenId, _uri);\n    LibAppStorage.layout().totalSupply.increment();\n    LibAppStorage.layout().minterNonce[sender].increment();\n    _safeMint(sender, _tokenId, _amount, '');\n\n    if (_amountOncyber > 0) {\n      _safeTransfer(\n        sender,\n        sender,\n        LibAppStorage.layout().oncyber,\n        _tokenId,\n        _amountOncyber,\n        ''\n      );\n    }\n\n    emit Minted(sender, _tokenId, _amount);\n\n    if (!isApprovedForAll(sender, LibAppStorage.layout().opensea)) {\n      setApprovalForAll(LibAppStorage.layout().opensea, true);\n    }\n\n    return _tokenId;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}